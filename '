use crate::prelude::*;

/// input: [gold] + [pure] * 5
///
/// output: [gold, blood, chassis] + [salt] * 3
pub fn chassis_factory() -> Blueprint {
    let mut bp = World::new();
    let mut inputs = vec![];
    let mut outputs = vec![];
    const ROWS: Coord = 5;

    // pre-calculate structure widths
    let refine_w = AirPump.width() + Refinery.width();
    let refines_w = refine_w * 3;
    let mana_w = refines_w + ROWS;
    let dhs_mana_x = mana_w;
    let dhs_curse_x = dhs_mana_x + Disharmonizer.width() * 2;
    let rfs_silica_x = dhs_curse_x + Disharmonizer.width();
    let dhs_plate_x = rfs_silica_x + Refinery.width();
    let ufs_x = dhs_plate_x + Disharmonizer.width();
    let factory_x = ufs_x + Unifier.width() * ROWS;

    let splits_x = SubdimensionalMarket.width() * 12 + ROWS;

    let refine_h = AirPump.height();
    let refines_h = ROWS * 2 * refine_h;
    let sells_y = refines_h;
    let factory_y = sells_y + SubdimensionalMarket.height() * 2;

    let merges_y = BigMerger.height() * 2;
    let big_merges_y = merges_y + Merger.height() * 4;

    let dust_i = 0;
    let salt_i = ROWS as usize * 4;
    let blood_i = salt_i + 2;
    let gold_i = blood_i + 5;
    // let refs_plate_w = dhs_curse_w + Refinery.width();
    // let dhs_plate_w = refs_plate_w + Disharmonizer.width();
    // let ufs_w = dhs_plate_w + Unifier.width() * 5;
    // let ufs_gem_h = Unifier.height() * 2;
    // let ufs_blood_h = ufs_gem_h + Unifier.height();
    // let merges_curse_h = ufs_blood_h - Merger.height();
    // let factory_w = ufs_w + Refinery.width();
    // let factory_h = refines_h;

    let sells = stack::<_, 28>(|i| {
        let y = refines_h + i % 2 * SubdimensionalMarket.height();
        let x = i / 2 * SubdimensionalMarket.width() + (i >= 12) as i16 * ROWS;
        bp.place(SubdimensionalMarket, x, y)
    });

    let merges = stack::<_, { ROWS as usize * 4 }>(|i| {
        let y = merges_y + i / ROWS * Merger.height();
        let x = refines_w + i % ROWS;
        bp.place(Merger, x, y)
    });

    let big_merges = stack::<_, { ROWS as usize }>(|i| {
        let y = big_merges_y;
        let x = refines_w + i;
        bp.place(BigMerger, x, y)
    });

    // mana gems and disharms
    let out_curse_silica = stack::<_, { ROWS as usize * 2 }>(|i| {
        let merge_y = i / ROWS * BigMerger.height();
        let merge = bp.place(BigMerger, refines_w + (i % ROWS), merge_y);
        let merge_port_last = BigMerger.connectors().inputs.len() - 1;

        let pump_y = i * refine_h;
        for j in 0..3 {
            let pump = bp.place(AirPump, j * refine_w, pump_y);
            let refine = bp.place(Refinery, j * refine_w + AirPump.width(), pump_y);
            bp.connect(pump.output(0), refine.input(0));
            bp.connect(refine.output(0), merge.input(merge_port_last - j as usize));
        }

        let dh_mana = bp.place(
            Disharmonizer,
            (i % 2) * Disharmonizer.width() + mana_w,
            (i / 2) * Disharmonizer.height(),
        );
        bp.connect(merge.output(0), dh_mana.input(0));
        bp.connect(dh_mana.output(0), sells[i as usize * 2 + 0].input(0));
        bp.connect(dh_mana.output(1), sells[i as usize * 2 + 1].input(0));
        (dh_mana.output(2), dh_mana.output(3))
    });

    let in_curse_silica_out_blood_bright = stack::<_, { ROWS as usize }>(|i| {
        let dh_curse = bp.place(Disharmonizer, dhs_curse_x, i * Disharmonizer.height());
        let rf_silica_y = i * Disharmonizer.height();
        let rf_silica_0 = bp.place(Refinery, rfs_silica_x, rf_silica_y);
        let rf_silica_1 = bp.place(Refinery, rfs_silica_x, rf_silica_y + Refinery.height());
        let dh_plate = bp.place(Disharmonizer, dhs_plate_x, i * Disharmonizer.height());
        let uf_x = ufs_x + Unifier.width() * i;
        let uf_blood = bp.place(Unifier, uf_x, Unifier.height() * 0);
        let uf_bright = bp.place(Unifier, uf_x, Unifier.height() * 1);
        let uf_bar = bp.place(Unifier, uf_x, Unifier.height() * 2);
        let uf_sheet = bp.place(Unifier, uf_x, Unifier.height() * 3);
        let mg_curse = merges[(ROWS * 0 + i) as usize];
        let mg_silica_0 = merges[(ROWS * 1 + i) as usize];
        let mg_silica_1 = merges[(ROWS * 2 + i) as usize];
        let mg_plate = merges[(ROWS * 3 + i) as usize];
        let sm_blood = sells[blood_i + i as usize];

        bp.connect(out_curse_silica[i as usize * 2 + 0].0, mg_curse.input(0));
        bp.connect(out_curse_silica[i as usize * 2 + 1].0, mg_curse.input(1));
        bp.connect(mg_curse.output(0), dh_curse.input(0));
        bp.connect(dh_curse.output(1), uf_blood.input(0));
        bp.connect(dh_curse.output(2), uf_blood.input(1));
        bp.connect(sells[i as usize].output(2), uf_blood.input(2));
        bp.connect(uf_blood.output(0), sm_blood.input(0));

        bp.connect(out_curse_silica[i as usize * 2 + 0].1, mg_silica_0.input(0));
        bp.connect(out_curse_silica[i as usize * 2 + 1].1, mg_silica_1.input(0));
        bp.connect(dh_plate.output(1), mg_silica_0.input(1));
        bp.connect(dh_plate.output(2), mg_silica_1.input(1));
        bp.connect(mg_silica_0.output(0), rf_silica_0.input(0));
        bp.connect(mg_silica_1.output(0), rf_silica_1.input(0));
        bp.connect(rf_silica_0.output(0), mg_plate.input(0));
        bp.connect(rf_silica_1.output(0), mg_plate.input(1));
        bp.connect(mg_plate.output(0), dh_plate.input(0));

        bp.connect(sm_blood.output(1), uf_bright.input(0));
        bp.connect(dh_plate.output(0), uf_bright.input(1));
        bp.connect(uf_bright.output(0), uf_sheet.input(1));
        inputs.push(uf_sheet.input(2));

        let out_salt = dh_curse.output(0);
        if i < 2 {
            bp.connect(out_salt, sells[salt_i + i as usize].input(0));
        } else {
            outputs.push(out_salt);
        }
    });

    Blueprint {
        contents: bp,
        size: Size {
            w: factory_x,
            h: factory_y,
        },
        inputs,
        outputs,
    }
}

pub fn chassis_demo() -> World {
    let mut world = World::new();
    let pure_vault_count = 3;
    let sv_bp = &storage(pure_vault_count, pure_vault_count, PureManaGem);
    let cf = world.place(&chassis_factory(), 0, 0);

    // let sv_g_bp = &storage(8 * 4, 4, GoldCoin);
    // let sv_gold = world.place(sv_g_bp, -sv_g_bp.width(), 0);
    // world.connect(sv_gold.output(0), cf.input(0));

    // let _ = stack::<_, 5>(|i| {
    //     let sv = world.place(sv_bp, -sv_bp.width(), sv_g_bp.height() + i * sv_bp.height());
    //     world.connect(sv.output(0), cf.input(i as usize + 1));
    // });
    // {
    //     let sv_spark = world.place(
    //         &storage(8 * 4, 4, Empty),
    //         0,
    //         cf.height() + StorageVault.height() * 4,
    //     );
    //     world.connect(cf.output(1), sv_spark.input(0));
    // }
    world
}

pub fn pure_chassis_demo() -> World {
    let mut world = World::new();
    let pf = &pure_factory();
    let pfs = stack::<_, 16>(|i| world.place(pf, 0, i * pf.height()));
    let (inputs, outputs) = chain_ports(&mut world, &pfs, [(0, 0), (1, 1)]).unwrap();
    world
}
